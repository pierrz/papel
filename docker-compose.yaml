---
version: "3.8"

volumes:
  backend-volume: {}
  data-volume: {}

x-airflow-common:
# Basic Airflow cluster configuration for CeleryExecutor with Redis and PostgreSQL 
# based on https://airflow.apache.org/docs/apache-airflow/stable/docker-compose.yaml
  &airflow-common
  image: "${AIRFLOW_IMAGE_NAME:-apache/airflow:2.0.1-python3.8}"
  environment:
    &airflow-common-env
    AIRFLOW__CORE__EXECUTOR: "CeleryExecutor"
    AIRFLOW__CORE__SQL_ALCHEMY_CONN: "postgresql+psycopg2://airflow:airflow@postgres/airflow"
    AIRFLOW__CELERY__RESULT_BACKEND: "db+postgresql://airflow:airflow@postgres/airflow"
    AIRFLOW__CELERY__BROKER_URL: "redis://:@redis:${REDIS_PORT}/0"
    AIRFLOW__CORE__FERNET_KEY: ""
    AIRFLOW__CORE__DAGS_ARE_PAUSED_AT_CREATION: "true"
    AIRFLOW__CORE__LOAD_EXAMPLES: "true"
  volumes:
    - ./dags:/opt/airflow/dags
    - ./logs:/opt/airflow/logs
    - ./plugins:/opt/airflow/plugins
  user: "${AIRFLOW_UID:-50000}:${AIRFLOW_GID:-50000}"
  depends_on:
    redis:
      condition: "service_healthy"
    postgres:
      condition: "service_healthy"

services:
  
  # airflow 
  postgres:
    container_name: "airflow_db_container"
    profiles: ["airflow"]
    image: "postgres:13"
    environment:
      POSTGRES_USER: "${AIRFLOW_DB_USER}"
      POSTGRES_PASSWORD: "${AIRFLOW_DB_PASSWORD}"
      POSTGRES_DB: "${AIRFLOW_DB}"
    volumes:
      - backend-volume:/var/lib/postgresql/data   # /!\
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "airflow"]
      interval: "5s"
      retries: 5
    restart: "always"
  
  redis:
    container_name: "airflow_redis_container"
    profiles: ["airflow"]
    image: "redis:latest"
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: "5s"
      timeout: "30s"
      retries: 50
    restart: "always"

  airflow-webserver:
    container_name: "airflow_webserver_container"
    profiles: ["airflow"]
    <<: *airflow-common
    command: webserver
    ports:
      - "${WEBSERVER_PORT}:${WEBSERVER_PORT}"
    healthcheck:
      test: ["CMD", "curl", "--fail", "${HOST_URL}${WEBSERVER_PORT}/health"]
      interval: "10s"
      timeout: "10s"
      retries: 5
    restart: "always"

  airflow-scheduler:
    <<: *airflow-common
    container_name: "airflow_scheduler_container"
    profiles: ["airflow"]
    command: scheduler
    restart: "always"
    
  airflow-worker:
    <<: *airflow-common
    container_name: "airflow_celery_container"
    profiles: ["airflow"]
    command: celery worker
    restart: "always"

  airflow-init:
    <<: *airflow-common
    container_name: "airflow_init_container"
    profiles: ["airflow"]
    command: version
    environment:
      <<: *airflow-common-env
      _AIRFLOW_DB_UPGRADE: "true"
      _AIRFLOW_WWW_USER_CREATE: "true"
      _AIRFLOW_WWW_USER_USERNAME: "${_AIRFLOW_WWW_USER_USERNAME:-airflow}"
      _AIRFLOW_WWW_USER_PASSWORD: "${_AIRFLOW_WWW_USER_PASSWORD:-airflow}"

  flower:
    <<: *airflow-common
    container_name: "airflow_flower_container"
    profiles: ["airflow"]
    command: celery flower
    ports:
      - "${FLOWER_PORT}:${FLOWER_PORT}"
    healthcheck:
      test: ["CMD", "curl", "--fail", "${HOST_URL}${FLOWER_PORT}/"]
      interval: "10s"
      timeout: "10s"
      retries: 5
    restart: "always"
      
  # stats
  pgadmin:
    container_name: "pgadmin4_container"
    profiles: ["stats"]
    image: "dpage/pgadmin4"
    restart: "always"
    environment:
      - PGADMIN_DEFAULT_EMAIL="${PGADMIN_DEFAULT_EMAIL}"
      - PGADMIN_DEFAULT_PASSWORD="${PGADMIN_DEFAULT_PASSWORD}"
    ports:
      - "${PGADMIN_PORT}"
  
  # TODO : Kibana
  
  # FastAPI
  fastapi:
    container_name: "fastapi_container"
    profiles: ["input"]
    image: "tiangolo/uvicorn-gunicorn-fastapi:python3.8"
    restart: "always"

  # source db
  mongo:
    container_name: "mongodb_container"
    profiles: ["input"]
    image: "mongo:latest"
    restart: "always"
    environment:
      - MONGO_INITDB_DATABASE="${MONGO_INITDB_DATABASE}"
      - MONGO_INITDB_ROOT_USERNAME="${MONGO_INITDB_ROOT_USERNAME}"
      - MONGO_INITDB_ROOT_PASSWORD="${MONGO_INITDB_ROOT_PASSWORD}"
      - MONGO_API_USER="${MONGO_API_USER}"
      - MONGO_API_PWD="${MONGO_API_PWD}"
    volumes:
      - data-volume:/etc/data/${MONGO_INITDB_DATABASE}
      - ./data:/mnt
      - ./docker-entrypoint-initdb.d/init-mongo.sh:/docker-entrypoint-initdb.d/init-mongo.sh:ro
      # - ./docker-entrypoint-initdb.d/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro

  mongo-express:
    container_name: "mongoexpress_container"
    profiles: ["input"]
    image: "mongo-express:latest"
    restart: "always"
    ports:
      - "${ME_CONFIG_MONGODB_PORT}:${ME_CONFIG_MONGODB_PORT}"
    environment:
      - ME_CONFIG_MONGODB_ADMINUSERNAME="${ME_CONFIG_MONGODB_ADMINUSERNAME}"
      - ME_CONFIG_MONGODB_ADMINPASSWORD="${ME_CONFIG_MONGODB_ADMINPASSWORD}"
    volumes:  
      - backend-volume:/var/lib/mongo

  # dev db
  postgres-dev:
    container_name: "devdb_container"
    profiles: ["output"]
    image: "postgres:13"  
    environment:
      POSTGRES_USER: "${DEV_DB_USER}"
      POSTGRES_PASSWORD: "${DEV_DB_PASSWORD}"
      POSTGRES_DB: "${DEV_DB}"
    volumes:  
      - data-volume:/etc/data/dev_db
      # - ./create_second_db.sh:/docker-entrypoint-initdb.d/create_second_db.sh
      - ./docker-entrypoint-initdb.d/create_second_db.sh:/docker-entrypoint-initdb.d/create_second_db.sh
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "devadmin"]
      interval: "5s"
      retries: 5
    restart: "always"
    ports:
      - "${DEV_DB_PORT}:${DEV_DB_PORT}"

  # TODO : Elastic ?
